#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon May 31 09:29:19 2021

@author: m2rob
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun May  2 17:23:59 2021

@author: m2rob
"""
"""
1.
建立与 CoppeliaSim 的连接：
为什么要做：为了将 Python 代码与 CoppeliaSim 模拟环境进行连接。CoppeliaSim 是一个机器人仿真工具，能够帮助你控制机器人并从模拟环境中获取数据。
你做了什么：使用 sim.simxStart 连接到 CoppeliaSim 服务器。之后，你通过 sim.simxGetObjectHandle 获取了 UR10 机械臂各个关节的句柄


2.
定义 Denavit-Hartenberg (DH) 参数和转换矩阵函数
a2 = 0.612
a3 = 0.5723
r1 = 0.1273
r2 = 0.163941
r5 = 0.1157
r7 = 0.0922

为什么要做：根据 DH 参数建立机械臂的运动学模型。这些参数描述了每个关节相对于上一个关节的偏移量和旋转角度。通过这些参数，你可以确定机械臂在三维空间中的姿态。
你做了什么：定义了 UR10 的 DH 参数，之后使用 MatrixTransformation 函数生成了每个关节的齐次变换矩阵 Ti(i−1)
​

3.
计算末端执行器的位置和方向
T01 = MatrixTransformation(u1)
T06 = T05 @ T56 
p7 = T06 @ O67


为什么要做：你需要知道机械臂末端执行器在空间中的位置和方向，这对于后续的控制和轨迹生成至关重要。
你做了什么：通过 DH 参数的齐次变换矩阵递推，得到了末端执行器相对于基坐标系的位置和方向。p7 代表末端执行器在当前姿态下的坐标。


4.
雅可比矩阵的计算
def Jacobien(theta_1val, theta_2val, theta_3val, theta_4val, theta_5val, theta_6val):
    # 计算雅可比矩阵

为什么要做：雅可比矩阵是机械臂运动学中的重要工具，它将关节空间的变化映射到末端执行器的速度和姿态变化。通过雅可比矩阵，可以得到机械臂的速度和加速度。
你做了什么：通过对末端位置p7和角度的偏导数，计算出雅可比矩阵，帮助你在后续的轨迹跟踪和控制中用到。


5.
轨迹生成（第 4 问）
def generate_trajectory(t, tf, Xi, Xf, Ri, u, theta):
    # 五阶多项式生成轨迹
为什么要做：为了让机械臂从初始位置平滑地移动到目标位置，且保证运动过程的平滑性。五阶多项式轨迹生成法可以确保初始和终止时的位置、速度和加速度连续。
你做了什么：根据时间 t 生成末端执行器的期望位置 xd 和期望的方向矩阵 Rd 你使用了五阶多项式来生成轨迹，确保在 t=0 和 t=tf时，轨迹是平滑的。

6. 误差计算（第 5 问）
def error(x_desired, R_d, T06):
    # 计算位置和方向误差
为什么要做：为了控制机器人，你需要计算当前状态与期望状态之间的误差。通过误差计算，可以决定如何调整机械臂的运动，以跟踪期望的轨迹。
你做了什么：计算了位置误差 ep 和方向误差 eo。位置误差是当前末端执行器位置与期望位置的差，方向误差通过实际方向矩阵与期望方向矩阵的列向量叉积计算得到。


7.控制律设计（第 6 问）


为什么要做：为了使机械臂跟踪期望的轨迹，你需要设计一个控制器。控制律将使用误差反馈，调整关节的角速度和角加速度，以实现轨迹跟踪。
你做了什么：虽然代码中尚未完全实现这部分内容，但根据题目要求，控制律可能涉及基于雅可比矩阵的反馈控制，利用  ep 和 eo 误差来计算出关节的角速度 q'



 总结：
你首先通过与 CoppeliaSim 连接，获取了 UR10 机械臂的关节句柄。
接着，你基于 Denavit-Hartenberg 参数建立了 UR10 的运动学模型，计算出末端执行器的位置和方向。
你推导了雅可比矩阵，用于描述关节空间和任务空间之间的关系。
你生成了机械臂的期望轨迹，包括位置和方向，并计算了当前状态与期望状态之间的误差。
最后，你将继续设计控制律，以便让机械臂根据误差调整其运动，跟踪期望轨迹。
这段代码结合了运动学、雅可比矩阵和控制律，是对 UR10 机械臂进行建模和控制的完整解决方案。
"""



# simRemoteApi.start(19999)


import numpy as np
import sim
import time
import math
import matplotlib.pyplot as plt
from control.matlab import *
import sympy as sp

if __name__ == '__main__':
    
    print ('Program started')
    sim.simxFinish(-1) # just in case, close all opened connections
    clientID=sim.simxStart('127.0.0.1',19999,True,True,5000,5) # Connect to CoppeliaSim

    h=np.array([0,0,0,0,0,0])
    q = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0])
    


    if clientID!=-1:
        print ('Connected to remote API server')

        # Now try to retrieve data in a blocking fashion (i.e. a service call):
        res,objs=sim.simxGetObjects(clientID,sim.sim_handle_all,sim.simx_opmode_blocking)
        if res==sim.simx_return_ok:
            print ('Number of objects in the scene: ',len(objs))
        else:
            print ('Remote API function call returned with error code: ',res)
            
        # Now retrieve streaming data (i.e. in a non-blocking fashion):
        startTime=time.time()
        sim.simxGetIntegerParameter(clientID,sim.sim_intparam_mouse_x,sim.simx_opmode_streaming) # Initialize streaming
           
        r, h[0]=sim.simxGetObjectHandle(clientID,'UR10_joint1', sim.simx_opmode_blocking)
        r, h[1]=sim.simxGetObjectHandle(clientID,'UR10_joint2', sim.simx_opmode_blocking)
        r, h[2]=sim.simxGetObjectHandle(clientID,'UR10_joint3', sim.simx_opmode_blocking)
        r, h[3]=sim.simxGetObjectHandle(clientID,'UR10_joint4', sim.simx_opmode_blocking)
        r, h[4]=sim.simxGetObjectHandle(clientID,'UR10_joint5', sim.simx_opmode_blocking)
        r, h[5]=sim.simxGetObjectHandle(clientID,'UR10_joint6', sim.simx_opmode_blocking)
        
            
        #############################################################################################################
        #                       Programme de la commande dÃ©bute ici
        #############################################################################################################



    ###
    #Question 1:
    ### 

        a2 = 0.612
        a3 = 0.5723
        r1 = 0.1273
        r2 = 0.163941
        r5 = 0.1157
        r7 = 0.0922

        theta_1, theta_2 ,theta_3 , theta_4 , theta_5 , theta_6 =sp.symbols('theta_1 theta_2 theta_3 theta_4 theta_5 theta_6')
        theta_1val= theta_2val =theta_3val = theta_4val=  theta_5val= theta_6val=0
        u1 = sp.Matrix([0,0,theta_1,r1])
        u2 = sp.Matrix([sp.pi/2,0,theta_2,r2])
        u3 = sp.Matrix([0,-a2,theta_3,0])
        u4 = sp.Matrix([0,-a3,theta_4,0])
        u5 = sp.Matrix([sp.pi/2,0,theta_5,r5])
        u6 = sp.Matrix([-sp.pi/2,0,theta_6,0])

        def MatrixTransformation(uj):

                

                Rot_x = sp.Matrix([
                    [1,0,0,0],
                    [0,sp.cos(uj[0]),-sp.sin(uj[0]),0],
                    [0,sp.sin(uj[0]),sp.cos(uj[0]),0],
                    [0,0,0,1]
                    ])  
                

                Trans_x = sp.Matrix([
                    [1,0,0,uj[1]],
                    [0,1,0,0],
                    [0,0,1,0],
                    [0,0,0,1]
                ])

                Rot_z = sp.Matrix([
                    [sp.cos(uj[2]),-sp.sin(uj[2]),0,0],
                    [sp.sin(uj[2]),sp.cos(uj[2]),0,0],
                    [0,0,1,0,],
                    [0,0,0,1]
                ])
            
                Trans_z = sp.Matrix([
                    [1,0,0,0],
                    [0,1,0,0],
                    [0,0,1,uj[3]],
                    [0,0,0,1]
                ])

                T = Rot_x @ Trans_x @ Rot_z @ Trans_z

                return T

        T01 = MatrixTransformation(u1)
        T12 = MatrixTransformation(u2)
        T23 = MatrixTransformation(u3)
        T34 = MatrixTransformation(u4)
        T45 = MatrixTransformation(u5)
        T56 = MatrixTransformation(u6)
        O67 = np.array([[0],[0],[r7],[1]])

        ###Je calcule les matrices pour préparer de déterminer les éléments de matrice Jacobien###
        T02 = T01 @ T12
        T03 = T02 @ T23
        T04 = T03 @ T34
        T05 = T04 @ T45
        T06 = T05 @ T56 
        p7 = T06 @ O67
        Xi = p7[:3,0]
        Ri = T06[:3,:3]
        tf = 20 #La durée de movement par exemple
        Xf = np.array([0.5],[0.5,[0.5]])
        theta_angle = np.pi


        ###
        #The position of end-effector is (delete # to show p7)
        #print(p7)
        print("----------------------------------------------------------------------------------------------------------")
        print("\n C'est pour montrer la position de l'organe terminal\nQuand les angles sont zeros\n")
        #Quand les angls égalent 0, la position de end-effector:
        p7_0 = sp.lambdify((theta_1, theta_2, theta_3, theta_4, theta_5, theta_6), p7)(theta_1val, theta_2val, theta_3val, theta_4val, theta_5val, theta_6val)
        print(p7_0)
        
        print("----------------------------------------------------------------------------------------------------------")
        print("\n C'est pour montrer le matrice de Jacobien\nQuand les angles sont zeros\n")

        #Function de Jacobien
        def Jacobien(theta_1val,theta_2val,theta_3val, theta_4val, theta_5val, theta_6val):
            x = p7[0]
            y = p7[1]
            z = p7[2]
            

            alpha = theta_1 - theta_5
            beta = -theta_2 - theta_3 - theta_4 - theta_6
            gamma = np.pi/2

            J11 = sp.diff(x,theta_1)
            J12 = sp.diff(x,theta_2)
            J13 = sp.diff(x,theta_3)
            J14 = sp.diff(x,theta_4)
            J15 = sp.diff(x,theta_5)
            J16 = sp.diff(x,theta_6)

            J21 = sp.diff(y,theta_1)
            J22 = sp.diff(y,theta_2)
            J23 = sp.diff(y,theta_3)
            J24 = sp.diff(y,theta_4)
            J25 = sp.diff(y,theta_5)
            J26 = sp.diff(y,theta_6)

            J31 = sp.diff(z,theta_1)
            J32 = sp.diff(z,theta_2)
            J33 = sp.diff(z,theta_3)
            J34 = sp.diff(z,theta_4)
            J35 = sp.diff(z,theta_5)
            J36 = sp.diff(z,theta_6)

            J41 = sp.diff(gamma,theta_1)
            J42 = sp.diff(gamma,theta_2)
            J43 = sp.diff(gamma,theta_3)
            J44 = sp.diff(gamma,theta_4)
            J45 = sp.diff(gamma,theta_5)
            J46 = sp.diff(gamma,theta_6)

            J51 = sp.diff(beta,theta_1)
            J52 = sp.diff(beta,theta_2)
            J53 = sp.diff(beta,theta_3)
            J54 = sp.diff(beta,theta_4)
            J55 = sp.diff(beta,theta_5)
            J56 = sp.diff(beta,theta_6)

            J61 = sp.diff(alpha,theta_1)
            J62 = sp.diff(alpha,theta_2)
            J63 = sp.diff(alpha,theta_3)
            J64 = sp.diff(alpha,theta_4)
            J65 = sp.diff(alpha,theta_5)
            J66 = sp.diff(alpha,theta_6)

            J = np.array([[J11,J12,J13,J14,J15,J16],
                        [J21,J22,J23,J24,J25,J26],
                        [J31,J32,J33,J34,J35,J36],
                        [J41,J42,J43,J44,J45,J46],
                        [J51,J52,J53,J54,J55,J56],
                        [J61,J62,J63,J64,J65,J66]])
            J_num = np.array([[sp.lambdify((theta_1, theta_2, theta_3, theta_4, theta_5, theta_6), entry)(theta_1val, theta_2val, theta_3val, theta_4val, theta_5val, theta_6val) for entry in row] for row in J])

            return J_num


        print("The matrix Jacobien est: \n")
        #Quand les angles égalent 0, le matrice de Jacobien egale: 
        J1 = Jacobien(0,0,0,0,0,0)
        print(J1)




        print("----------------------------------------------------------------------------------------------------------")
        ###
        #I treated the questions 1  2  3 in a same function

        def kinematics(joint_pos):
            deta1,deta2,deta3,deta4,deta5,deta6 = joint_pos
            
            u1 = sp.Matrix([0,0,deta1,r1])
            u2 = sp.Matrix([sp.pi/2,0,deta2,r2])
            u3 = sp.Matrix([0,-a2,deta3,0])
            u4 = sp.Matrix([0,-a3,deta4,0])
            u5 = sp.Matrix([sp.pi/2,0,deta5,r5])
            u6 = sp.Matrix([-sp.pi/2,0,deta6,0])   
            T06 = MatrixTransformation(u1)*MatrixTransformation(u2)*MatrixTransformation(u3)*MatrixTransformation(u4)*MatrixTransformation(u5)*MatrixTransformation(u6)
            J = Jacobien(deta1,deta2,deta3,deta4,deta5,deta6)
            print("\nC'est la position de l'organe terminal\n avec la fonction kinematics\n")
            print(T06)
            print("\nC'est la matrice de Jacobien\n avec la fonction kinematics\n")
            print(J)

            return T06,J
        

        Q = ([2,2,2,2,2,2])#On entre les angles de l'articulaire par example
        A,B = kinematics(Q)#On obtient le matrice de transformation et la matrice Jacobien 

        ###
        #Question 4:Generat	the trajectory
        ###
        
        def generate_trajectory(t, tf, Xi, Xf, Ri, u, theta):
            # r(t) the 5th order	polynomial equation
            r = 10 * (t/tf)**3 - 15 * (t/tf)**4 + 6 * (t/tf)**5
            
            # position desired
            x_d = Xi + r * (Xf - Xi)
            
            # rotation angle
            r_theta = r * theta
            
            # matrix rotation rot(u, r(t) * theta)
            ux, uy, uz = u  
            cos_r_theta = np.cos(r_theta)
            sin_r_theta = np.sin(r_theta)
            one_minus_cos = 1 - cos_r_theta
            
            
            R_rot = np.array([
                [ux**2 * one_minus_cos + cos_r_theta, ux * uy * one_minus_cos - uz * sin_r_theta, ux * uz * one_minus_cos + uy * sin_r_theta],
                [ux * uy * one_minus_cos + uz * sin_r_theta, uy**2 * one_minus_cos + cos_r_theta, uy * uz * one_minus_cos - ux * sin_r_theta],
                [ux * uz * one_minus_cos - uy * sin_r_theta, uy * uz * one_minus_cos + ux * sin_r_theta, uz**2 * one_minus_cos + cos_r_theta]
            ])
            
            # matrix orientation final
            R_d = np.dot(Ri, R_rot)
            
            return x_d, R_d
            
        def error(x_desired,R_d,p7):
            ne = T06[:3,0]
            se = T06[:3,1]
            ae = T06[:3,2]
            nd = R_d[:3,0]
            sd = R_d[:3,1]
            ad = R_d[:3,2]
            x_actual = p7
            ep = x_desired - x_actual
            eo = 1/2(np.cross(ne,nd)+np.cross(se,sd)+np.cross(ae,ad))

            return ep,eo
        

        

            

        


    else:
        print ('Failed connecting to remote API server')
    print ('Program ended')
